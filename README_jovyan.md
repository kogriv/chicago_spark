## а что вообще такое этот "jovyan"
"Jovyan" — это стандартное имя пользователя, используемое в официальных Docker образах Jupyter. Это традиция, идущая от слова "Jove", которое является поэтическим именем Юпитера (Jupiter), верховного бога в римской мифологии. Поскольку Jupyter является аббревиатурой от Julia, Python и R (трех основных языков программирования, используемых в научных вычислениях), имя пользователя "jovyan" является игрой слов и отсылкой к Юпитеру.

В контексте Docker и Jupyter, это просто имя пользователя внутри Docker-контейнера. Когда вы запускаете Docker-контейнер с одним из официальных образов Jupyter, по умолчанию вы работаете под пользователем "jovyan" внутри контейнера. Это имя пользователя обычно имеет ограниченные привилегии для повышения безопасности, но при этом имеет достаточно прав для выполнения обычных задач, связанных с Jupyter и научными вычислениями.

Когда вы видите директорию /home/jovyan, это домашняя директория этого пользователя внутри Docker-контейнера.

## рабочая директория jupyter
Jupyter Lab по умолчанию использует домашнюю директорию пользователя в контейнере (/home/jovyan для официальных образов Jupyter Docker) в качестве корневой директории рабочего пространства. Однако, это поведение можно изменить, указав аргумент --NotebookApp.notebook_dir при запуске контейнера, как вы уже сделали в вашем скрипте. Этот аргумент заставит Jupyter использовать указанную директорию в качестве начальной точки.

Если Jupyter всё равно запускается в домашней директории, возможно, проблема может быть в следующем:

- Переменная среды JUPYTERLAB_DIR может быть задана внутри Dockerfile или в конфигурационном файле Jupyter, переопределяя аргумент командной строки.
- Docker контейнер не был перезапущен после изменения конфигурации, и поэтому старая конфигурация осталась активной.
- Проблемы с правами доступа, из-за которых Jupyter не может использовать директорию /work и возвращает пользователя в домашнюю директорию.

## как в проводнике на хост машине попасть в папку /home/jovyan данного контейнера
Нет, непосредственно в проводнике Windows вы не можете получить доступ к файловой системе Docker контейнера, потому что она изолирована от хост-операционной системы. Файловая система контейнера существует только внутри самого контейнера и не отображается в файловой системе хоста напрямую.

Однако, если вам необходимо скопировать файлы из директории /home/jovyan в контейнере на хост-машины, вы можете сделать следующее:

Копирование файлов с помощью команды docker cp:
- Вы можете использовать команду docker cp для копирования файлов между контейнером и хост-машиной. Вот пример команды, которая копирует файлы из контейнера на хост:
```bash
docker cp <container_id>:/home/jovyan /path/to/destination/on/host
```
- Использование примонтированных томов:
Если вы хотите, чтобы файлы автоматически синхронизировались между контейнером и хостом, вам нужно использовать тома (volumes) Docker для монтирования директории хоста в контейнер. Вы можете примонтировать любую директорию хоста к `/home/jovyan/work` в контейнере.

## синхронизация
Запустите контейнер и войдите в него:
```bash
docker exec -it jupyter_lab bash
```
Затем, внутри контейнера, обновите список пакетов и установите rsync:
```bash
apt-get update
apt-get install -y rsync
```

Если вы хотите, чтобы rsync был доступен в контейнере постоянно, вам нужно добавить команду установки в Dockerfile, используемый для создания образа Jupyter. Вот пример строки, которую нужно добавить в Dockerfile:
```bash
RUN apt-get update && apt-get install -y rsync
```

Ниже представлен пример скрипта sync.sh, который синхронизирует содержимое между директорией /home/jovyan/work и /work/notebooks:
```bash
#!/bin/bash

# Бесконечный цикл
while true; do
  # Синхронизация содержимого папки /home/jovyan/work с /work/notebooks
  rsync -av --delete /home/jovyan/work/ /work/notebooks/

  # Пауза в 1 минуту (60 секунд) перед следующей синхронизацией
  sleep 60
done
```
Этот скрипт делает следующее:

rsync -av --delete: команда rsync с опциями для копирования всех файлов (-a для архивного режима, который сохраняет символические ссылки, права доступа, и т.д., и -v для подробного вывода). Флаг --delete удаляет файлы в целевой директории, которых нет в исходной.
/home/jovyan/work/ /work/notebooks/: пути к исходной и целевой директориям для синхронизации.
sleep 60: команда ожидания, которая приостанавливает скрипт на 60 секунд между итерациями синхронизации.
Чтобы запустить этот скрипт:

Сохраните его в файл внутри контейнера, например, sync.sh.
Сделайте этот скрипт исполняемым: chmod +x sync.sh.
Запустите скрипт: ./sync.sh & (амперсанд & запускает скрипт в фоновом режиме).
Обратите внимание, что это решение подразумевает, что директория /work/notebooks существует. Если нет, создайте её с помощью команды mkdir -p /work/notebooks перед запуском скрипта.

## убить скрипт

найти запущенный скрипт с помощью команды ps:
```bash
ps aux | grep sync.sh
```

используйте команду kill для его завершения:
```bash
kill -9 PID
```
example:
```bash
root        9165  0.0  0.0   7500  3944 pts/1    S    10:20   0:00 /bin/bash ./sync.sh
root        9400  0.0  0.0   6608  2248 pts/1    S+   10:22   0:00 grep --color=auto sync.sh
```
скрипт sync.sh запущен с PID 9165. Чтобы его остановить, вам нужно выполнить команду kill с этим PID
```bash
kill 9165
```
Если скрипт не останавливается (иногда процессы могут игнорировать обычный сигнал kill), вы можете использовать сигнал SIGKILL, который отправляется с помощью -9

процесс:
```bash
root        9542  0.0  0.0   6608  2220 pts/1    S+   10:24   0:00 grep --color=auto sync.sh
```
cоответствует самой команде grep, которую вы использовали для поиска процесса sync.sh. Каждый раз, когда вы выполняете grep, он запускается как отдельный процесс для поиска указанных строк в активных процессах. Поскольку grep ищет строку "sync.sh", он также находит сам себя в списках процессов.

Этот процесс grep существует только в течение очень короткого времени, пока выполняется поиск. После отображения результатов команда grep завершается, так что нет необходимости его останавливать или убивать. То, что вы видите, это просто моментальный снимок процесса grep во время его выполнения командой ps.

## ядра юпитера
Для того, чтобы пользоваться нужной версией питона, добавьте путь в переменную окружения:
```bash
export PATH=export PATH=/usr/local/spark/bin:/usr/bin:$PATH:/usr/bin:$PATH
```

При этом вызов `python` будет по прежнему открывать интерпритатор контейнера по умолчанию (например 3.11.6). Вызов `python3` откроет инетрпритатор из `PATH=/usr/local/spark/bin` (Python 3.8.10). Также и менеджер пакетов - использование `pip` будет устанавливать пакеты для интерпритатора по умолчанию. ЕСли нужна среда 3.8.10, используйте `pip3`.

Если модуль `ipykernel` не установлен для вашей версии `Python 3.8.10`, вы получите сообщение об ошибке "No module named ipykernel". Для решения этой проблемы вам нужно установить ipykernel для Python 3.8.10.
```bash
pip3 install ipykernel
```

После установки модуля ipykernel вы сможете использовать команду для добавления ядра в Jupyter с именем python38.
```bash
python3 -m ipykernel install --user --name=python38
```

Если вы используете виртуальное окружение Python, то активация среды происходит с помощью команды source или . (точка) в зависимости от вашей операционной системы и используемого оболочки.
```bash
source /путь_к_вашей_среде/bin/activate
```

Вы можете проверить доступные ядра в Jupyter, выполнив следующую команду в терминале:
```bash
jupyter kernelspec list
```

При установке нового ядра IPython вам придется установить все необходимые библиотеки и зависимости для этого ядра.
```bash
pip3 install -r requirements.txt
```

При установке
```bash
python3 -m ipykernel install --user --name=python_38
```
Может возникнуть ошибка:
```bash
...
ImportError: 
IPython 8.13+ supports Python 3.9 and above, following NEP 29.
IPython 8.0-8.12 supports Python 3.8 and above, following NEP 29.
When using Python 2.7, please install IPython 5.x LTS Long Term Support version.
Python 3.3 and 3.4 were supported up to IPython 6.x.
Python 3.5 was supported with IPython 7.0 to 7.9.
Python 3.6 was supported with IPython up to 7.16.
Python 3.7 was still supported with the 7.x branch.
...
```
Проблема заключается в том, что установленная версия IPython не поддерживает Python 3.8. Нужно установить совместимую версию IPython.

Установим IPython версии 8.0-8.12, которая поддерживает Python 3.8.
```bash
pip3 install ipython==8.12
```

